/*
	This code was generated by a tool. (c) 2019 HQ.IO Corporation. All rights reserved.
*/

using System;
using System.Net;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using Microsoft.Extensions.Options;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.AspNetCore.JsonPatch;
using Microsoft.AspNetCore.Authorization;
using Morcatko.AspNetCore.JsonMergePatch;
using ErrorStrings = HQ.Data.Contracts.ErrorStrings;
using HQ.Common;
using HQ.Data.Contracts.AspNetCore.Mvc;
using HQ.Data.Contracts.Configuration;
using HQ.Data.Contracts;
using HQ.Platform.Api.Configuration;
using HQ.Platform.Api.Extensions;
using HQ.Platform.Api.Filters;
using HQ.Platform.Runtime.Rest.Attributes;

namespace HQ.Template
{
    [ServiceFilter(typeof(HttpCacheFilterAttribute))]
    [ApiExplorerSettings(IgnoreApi = false, GroupName = "v1")]
    public partial class PersonController : DataController, IPersonController
    {
        private readonly HQ.Template.IPersonRepository _repository;
        private readonly IOptions<QueryOptions> _queryOptions;
        private readonly IOptions<PublicApiOptions> _apiOptions;
        private readonly Lazy<FieldOptions> _idField = new Lazy<FieldOptions>(() =>
        {
            var fields = new FieldOptions();
            fields.Fields.Add(nameof(IObject.Id));
            return fields;
        });

        public Type ObjectType => typeof(Person);

        public PersonController(HQ.Template.IPersonRepository repository, IOptions<QueryOptions> queryOptions, IOptions<PublicApiOptions> apiOptions)
        {
            _repository = repository;
            _queryOptions = queryOptions;
            _apiOptions = apiOptions;
        }


        #region GET

        [Authorize(Policies.RetrievePeople), HttpGet("people"),  HttpGet("people.{format}"), ResourceFilter, FormatFilter]
        public virtual async Task<IActionResult> GetAsync(SortOptions sort, PageOptions page, StreamOptions stream, FieldOptions fields, FilterOptions filter, ProjectionOptions projection, [FromQuery] IEnumerable<long> ids = null, [FromQuery] string query = null, [FromQuery] long startingAt = 0, [FromQuery] int? count = null)
        {
            // ReSharper disable once PossibleMultipleEnumeration
            if (ids != null && (count.HasValue && count > 0 || ids.Any()))
            {
                // ReSharper disable once PossibleMultipleEnumeration
                var slice = await _repository.GetAsync(ids, startingAt, count, fields, filter, projection);
                if (slice?.Data?.Count == 0)
                    return NotFound();
                Response.MaybeEnvelope(Request, _apiOptions.Value, _queryOptions.Value, slice?.Data, slice?.Errors, out var body);
                return Ok(body);
            }
            else
            {
                var slice = await _repository.GetAsync(query, sort, page, fields, filter, projection);
                if (slice?.Data?.Count == 0)
                    return NotFound();
                Response.MaybeEnvelope(Request, _apiOptions.Value, _queryOptions.Value, slice?.Data, slice?.Errors, out var body);
                return Ok(body);
            }
        }

        [Authorize(Policies.RetrievePeople), HttpGet("people/{id}"), HttpGet("people/{id}.{format}"), FieldsFilter, ProjectionFilter, FormatFilter]
        public virtual async Task<IActionResult> GetAsync([FromRoute, BindRequired] long id, FieldOptions fields, ProjectionOptions projection)
        {
            var @object = await _repository.GetAsync(id, fields);
            if (@object?.Data == null)
                return NotFound();
            Response.MaybeEnvelope(Request, _apiOptions.Value, _queryOptions.Value, @object.Data, @object.Errors, out var body);
            return Ok(body);
        }

        #endregion

        #region POST

        [Authorize(Policies.CreatePeople), HttpPost("people")]
        public virtual async Task<IActionResult> PostAsync([FromBody] Person @object)
        {
            if (@object.Id != 0)
            {
                if (await GetAsync(@object.Id, _idField.Value, ProjectionOptions.Empty) != null)
                {
                    // If trying to create an existing @object by mistake, use REST constraints:
                    // https://tools.ietf.org/html/rfc7231#section-4.3.3
                    return SeeOther($"{Request.Path}/{@object.Id}");
                }
                var error = new Error(ErrorEvents.InvalidRequest, "Cannot create an object with a pre-specified identifier.", HttpStatusCode.Forbidden);
                return new ErrorResult(error);
            }
            return await SaveAsync(@object);
        }

        [Authorize(Policies.CreatePeople), HttpPost("people/batch")]
        public virtual async Task<IActionResult> PostAsync([FromBody] IEnumerable<Person> objects, long startingAt = 0, int? count = null)
        {
            if (objects == null || count.HasValue && count.Value == 0 || !objects.Any())
                return Error(new Error(ErrorEvents.ResourceMissing, ErrorStrings.ResourceMissingInSave, HttpStatusCode.UnprocessableEntity));
            return await SaveAsync(objects, startingAt, count, BatchSaveStrategy.Insert);
        }

        #endregion

        #region PUT

        [Authorize(Policies.UpdatePeople), HttpPut("people/{id}")]
        public virtual async Task<IActionResult> PutAsync([FromRoute] long id, Person @object)
        {
            if (@object == null)
                return Error(new Error(ErrorEvents.ResourceMissing, ErrorStrings.ResourceMissingInSave, HttpStatusCode.UnprocessableEntity));
            var existing = await _repository.GetAsync(id);
            if (existing == null)
                return NotFound();
            @object.Id = id;
            return await SaveAsync(@object);
        }

        [Authorize(Policies.UpdatePeople), HttpPut("people")]
        public virtual async Task<IActionResult> PutAsync([FromBody] IEnumerable<Person> objects, long startingAt = 0, int? count = null)
        {
            if (objects == null || count.HasValue && count.Value == 0 || !objects.Any())
                return Error(new Error(ErrorEvents.ResourceMissing, ErrorStrings.ResourceMissingInSave, HttpStatusCode.UnprocessableEntity));
            return await SaveAsync(objects, startingAt, count, BatchSaveStrategy.Upsert);
        }

        #endregion

        #region PATCH

        [Authorize(Policies.UpdatePeople), HttpPatch("people/{id}")]
        public virtual async Task<IActionResult> PatchAsync([FromRoute] long id, JsonPatchDocument<Person> patch)
        {
            if (!Valid(patch, out var error))
                return error;

            var @object = await _repository.GetAsync(id);
            if (@object?.Data == null)
                return NotFound();

            patch.ApplyTo(@object.Data);
            return await SaveAsync(@object.Data);
        }

        [Authorize(Policies.UpdatePeople), HttpPatch("people/{id}/merge")]
        public virtual async Task<IActionResult> PatchAsync([FromRoute] long id, JsonMergePatchDocument<Person> patch)
        {
            if (!Valid(patch, out var error))
                return error;

            var @object = await _repository.GetAsync(id);
            if (@object?.Data == null)
                return NotFound();

            patch.ApplyTo(@object.Data);
            return await SaveAsync(@object.Data);
        }

        [Authorize(Policies.UpdatePeople), HttpPatch("people")]
        public virtual async Task<IActionResult> PatchAsync([FromBody] IEnumerable<Person> objects, long startingAt = 0, int? count = null)
        {
            if (objects == null || count.HasValue && count.Value == 0 || !objects.Any())
                return Error(new Error(ErrorEvents.ResourceMissing, ErrorStrings.ResourceMissingInSave, HttpStatusCode.UnprocessableEntity));
            return await SaveAsync(objects, startingAt, count, BatchSaveStrategy.Update);
        }

        #endregion

        #region DELETE

        [Authorize(Policies.DeletePeople), HttpDelete("people"), FilterFilter]
        public virtual async Task<IActionResult> DeleteAsync(FilterOptions filter)
        {
            var toDelete = await _repository.GetAsync(null, SortOptions.Empty, PageOptions.Empty, FieldOptions.Empty, filter, ProjectionOptions.Empty);
             if (toDelete?.Data == null)
                return NotFound();

            var operation = await _repository.DeleteAsync(toDelete.Data);
            return operation.ToResult();
        }

        [Authorize(Policies.DeletePeople), HttpDelete("people/{id}")]
        public virtual async Task<IActionResult> DeleteAsync([FromRoute] long id)
        {
            var toDelete = await _repository.GetAsync(id, FieldOptions.Empty, ProjectionOptions.Empty);
             if (toDelete?.Data == null)
                return NotFound();

            var operation = await _repository.DeleteAsync(toDelete.Data);
            return operation.ToResult(body =>
            {
                switch (operation.Data)
                {
                    case ObjectDelete.NotFound:
                        return NotFound();
                    case ObjectDelete.Deleted:
                        return NoContent();
                    case ObjectDelete.Gone:
                        return Gone();
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            });
        }

        [Authorize(Policies.DeletePeople), HttpDelete("people/{ids}")]
        public virtual async Task<IActionResult> DeleteAsync([FromQuery] IEnumerable<long> ids, [FromQuery] long startingAt = 0, [FromQuery] int? count = null)
        {
            var toDelete = await _repository.GetAsync(ids, startingAt, count, FieldOptions.Empty, FilterOptions.Empty, ProjectionOptions.Empty);
            if (toDelete == null)
                return NotFound();

            var operation = await _repository.DeleteAsync(toDelete.Data);
            return operation.ToResult();
        }

        #endregion

        private async Task<IActionResult> SaveAsync(Person @object)
        {
            if (!Valid(@object, out var error))
                return error;

            var operation = await _repository.SaveAsync(@object);
            return operation.ToResult(body =>
            {
                // See: https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#75-standard-request-headers
                if (Request.Headers.TryGetValue(Constants.HttpHeaders.Prefer, out var prefer) && prefer.ToString().ToUpperInvariant().Replace(" ", string.Empty).Equals("RETURN=MINIMAL"))
                    body = null;

                switch (operation.Data)
                {
                    case ObjectSave.NotFound:
                        return NotFound();
                    case ObjectSave.NoChanges:
                        return NotModified();
                    case ObjectSave.Updated:
                        return Ok(body);
                    case ObjectSave.Created:
                        return Created(new Uri($"{Request.Path}/{@object.Id}", UriKind.Relative), body);
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            });
        }

        private async Task<IActionResult> SaveAsync([FromBody] IEnumerable<Person> objects, long startingAt, int? count = null, BatchSaveStrategy strategy = BatchSaveStrategy.Insert)
        {
            var errors = new List<Error>();
            objects = objects.Where(x =>
            {
                if (TryValidateModel(x, $"{x.Id}")) return true;
                errors.Add(ConvertModelStateToError());
                return false;
            });
            var result = await _repository.SaveAsync(objects, strategy, startingAt, count);
            foreach (var error in errors)
                result.Errors.Add(error);
            Response.MaybeEnvelope(Request, _apiOptions.Value, _queryOptions.Value, null, result.Errors, out var body);
            return Ok(body);
        }
    }
}

